//void sur::Master::Move(Vec2f direction, bool detect)
//{
//	if(direction.x > 0)
//		counterpos.x += direction.x;
//	else
//		counterneg.x += direction.x;
//	if (direction.y > 0)
//		counterpos.y += direction.y;
//	else
//		counterneg.y += direction.y;
//	direction = { 0,0 };
//	while (counterpos.x >= (f32)countercountpos.x) {
//		direction.x += 1;
//		countercountpos.x++;
//	}
//	while (counterpos.y >= (f32)countercountpos.y) {
//		direction.y += 1;
//		countercountpos.y++;
//	}
//	while (counterneg.x <= (f32)countercountneg.x) {
//		direction.x -= 1;
//		countercountneg.x--;
//	}
//	while (counterneg.y <= (f32)countercountneg.y) {
//		direction.y -= 1;
//		countercountneg.y--;
//	}
//	direction.y *= -1;
//	if (detect) {
//		i32 CurMove = 0;
//		if (direction.y > 0) {	//Up
//			for (i32 a = 1; a <= direction.y; a++) {
//				for (i32 i = position.x; i < position.x + size.x; i++) {
//					for (i32 j = 0; j < trigger_identitys.size(); j++) {
//						if (_Amap.Trigger(i, position.y - a - 1) == trigger_identitys[j]) {
//							MessageBoxA(NULL, "Trigger", "Trigger", MB_ICONERROR);
//						}
//					}
//					for (i32 j = 0; j < identitys.size(); j++) {				
//						if (_debug)
//							_Amap.Render(i, position.y - a - 1, Color(0, 255, 0));
//						if (_Amap.Collider(i, position.y - a - 1) == identitys[j] && this->id != identitys[j]) {
//							if (callback != nullptr)
//								callback((Master*)this, (Master*)ptrs[j]);
//							if (static_cast<Master*>(ptrs[j])->callback != nullptr)
//								static_cast<Master*>(ptrs[j])->callback((Master*)(ptrs[j]), this);
//							goto dir1;
//						}	
//					}
//				}
//				CurMove = a;
//			}
//		dir1:
//			MoveInject(1, CurMove);
//		}
//		if (direction.x > 0) {	//Right
//			for (i32 a = 1; a <= direction.x; a++) {
//				for (i32 i = position.y; i < position.y + size.y; i++) {
//					for (i32 j = 0; j < trigger_identitys.size(); j++) {
//						if (_Amap.Trigger(position.x + size.x + a - 1, i) == trigger_identitys[j]) {
//							MessageBoxA(NULL, "Trigger", "Trigger", MB_ICONERROR);
//						}
//					}
//					for (i32 j = 0; j < identitys.size(); j++) {
//						if (_debug)
//							_Amap.Render(position.x + size.x + a - 1, i, Color(0, 255, 0));
//						if (_Amap.Collider(position.x + size.x + a - 1, i) == identitys[j] && this->id != identitys[j]) {
//							if (callback != nullptr)
//								callback((Master*)this, (Master*)ptrs[j]);
//							if (static_cast<Master*>(ptrs[j])->callback != nullptr)
//								static_cast<Master*>(ptrs[j])->callback((Master*)ptrs[j],this);
//							goto dir2;
//						}			
//					}
//				}
//				CurMove = a;
//			}
//		dir2:
//			MoveInject(2, CurMove);
//		}
//		if (direction.y < 0) {	//Down
//			direction.y *= -1;
//			for (i32 a = 0; a <= direction.y; a++) {
//				for (i32 i = position.x; i < position.x + size.x; i++) {
//					for (i32 j = 0; j < trigger_identitys.size(); j++) {
//						if (_Amap.Trigger(i, position.y + size.y + a) == trigger_identitys[j]) {
//							MessageBoxA(NULL, "Trigger", "Trigger", MB_ICONERROR);
//						}
//					}
//					for (i32 j = 0; j < identitys.size(); j++) {			
//						if (_debug)
//							_Amap.Render(i, position.y + size.y + a, Color(0, 255, 0));
//						if (_Amap.Collider(i, position.y + size.y + a) == identitys[j] && this->id != identitys[j]) {
//							if (callback != nullptr)
//								callback((Master*)this, (Master*)ptrs[j]);
//							if (static_cast<Master*>(ptrs[j])->callback != nullptr)
//								static_cast<Master*>(ptrs[j])->callback((Master*)ptrs[j], this);
//							goto dir3;
//						}
//					}
//				}
//				CurMove = a;
//			}
//		dir3:
//			MoveInject(3, CurMove);
//		}
//		if (direction.x < 0) {	//Left
//			direction.x *= -1;
//			for (i32 a = 1; a <= direction.x; a++) {
//				for (i32 i = position.y; i < position.y + size.y; i++) {
//					for (i32 j = 0; j < trigger_identitys.size(); j++) {
//						if (_Amap.Trigger(position.x - a - 1, i) == trigger_identitys[j]) {
//							MessageBoxA(NULL, "Trigger", "Trigger", MB_ICONERROR);
//						}
//					}
//					for (i32 j = 0; j < identitys.size(); j++) {
//						if (_debug)
//							_Amap.Render(position.x - a - 1, i, Color(0, 255, 0));
//						if (_Amap.Collider(position.x - a - 1, i) == identitys[j] && this->id != identitys[j]) {
//							if (callback != nullptr)
//								callback((Master*)this, (Master*)ptrs[j]);
//							if (static_cast<Master*>(ptrs[j])->callback != nullptr)
//								static_cast<Master*>(ptrs[j])->callback((Master*)ptrs[j],this);
//							goto dir4;
//						}
//					}
//				}
//				CurMove = a;
//			}
//		dir4:
//			MoveInject(4, CurMove);
//		}
//	}
//	else {
//		if (direction.y > 0)
//			position.y -= (i32)direction.y;
//		if (direction.x > 0)
//			position.x += (i32)direction.x;
//		if (direction.y < 0)
//			position.y -= (i32)direction.y;
//		if (direction.x < 0)
//			position.x += (i32)direction.x;
//	}
//}